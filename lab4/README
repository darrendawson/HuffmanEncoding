Darren Dawson, dwdawson@ucsc.edu
Lab 4, Multithreading


About Lab
----------
This program is a demo for implementing multi-threading in C. It utilizes <pthread.h> to handle multiple threads.
The objective of this program was to increment a global variable by n*1000 times (where n is determined from the command line). 
The program can create a user determined number of threads that will each add 1000 to the global counter.


Structure of Program
----------------------
 1) Declare variables. Initialize the mutex here (it is a global variable but needs to be instatiated)
 2) Get arguments. Set numberOfThreads
 3) Assign memory for threads and counts (number of times each thread will increment counter)
 4) Create and Run Threads
	When you create a thread, you point it to a void *function that it will act as its own little main
	For these threads, I used void *work(void *count)
	count gets converted back into a long, which is used to let the thread know how many times it should call increment
 4.5) Threads run
	Because each thread has its own stack, their individual count's (# of increments left) are put on their respective stacks.
	This makes keeping track of how many times each thread should increment super easy - just a simple for loop! 
	No dynamic memory allocation needed, since it's pushed to the stack as a thread-local variable anyway (and returned when we need it)
 5) Print the global variable counter
 6) free up memory



Keeping it thread safe
-----------------------
In order to make sure that only one thread could increment the global counter at a time (and thus avoid race conditions), 
 I made the increment function thread safe. By utilizing a mutex, only one thread could run the function at any given time.
 This way, no matter how the processor decides to perform a context switch, the program increments the correct number of times.



How does the mutex work?
-------------------------
The mutex acts as a lock. My function increment() locks the mutex on its way in and unlocks it on its way out.
In pseudocode:

	  increment()
	    lock(mutex)
	    increment(global count)
	    unlock(mutex)
	    return

Because the mutex gets locked when the function starts, if the processor context switches away from the thread, no other thread
 can get past the lock(mutex) step of increment(). These form a line for once the original thread finished and unlocks the mutex.
 As such, threads are able to perform their functions in a non-ordered but thread-safe way and the final counter will be deterministic.



Weird Things
-------------
I saw on Piazza that I should dynamically allocate memory for the number of times each thread will increment the global counter.
  The logic behind this was because theoretically you could want a system where different threads increment different amounts.
  In practice, each thread adds the same amount every time, so it would make more sense to just have one constant.
  Never the less, I calloc'd memory for an array of counts so that, if you really wanted, they could all be different.
  I then looped through them to make sure they were all the same base of n = 1000.  
  This was weird but didn't really change the program.

